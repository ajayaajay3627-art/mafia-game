<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Protocol: MAFIA</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./icon.png">
    <meta name="theme-color" content="#000000">

    <!-- Tailwind CSS -->
    <!-- Tailwind CSS -->
    <!-- NOTE: cdn.tailwindcss.com should not be used in production. For production, install via PostCSS or CLI. -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            background-color: #050505;
            color: #00ff41;
            font-family: 'VT323', monospace;
            overflow-x: hidden;
        }

        /* Scanline effect */
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0, 0, 0, 0) 0%, rgba(0, 255, 65, 0.04) 50%, rgba(0, 0, 0, 0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% {
                bottom: 100%;
            }

            100% {
                bottom: -100%;
            }
        }

        /* CRT flicker */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .neon-border {
            box-shadow: 0 0 10px #00ff41, inset 0 0 10px #00ff41;
        }

        .neon-text {
            text-shadow: 0 0 5px #00ff41;
        }

        .mafia-text {
            color: #ff003c;
            text-shadow: 0 0 10px #ff003c;
        }

        .civilian-text {
            color: #00ff41;
            text-shadow: 0 0 10px #00ff41;
        }

        .hidden {
            display: none !important;
        }

        /* Custom Input Style */
        .cyber-input {
            width: 100%;
            background-color: black;
            border-bottom: 2px solid #00ff41;
            padding: 0.75rem;
            text-align: center;
            font-size: 1.5rem;
            line-height: 2rem;
            color: #00ff41;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            caret-color: #00ff41;
        }

        .cyber-input:focus {
            border-color: white;
        }

        .cyber-input::placeholder {
            color: #1f2937;
        }

        /* Custom Button Style */
        .cyber-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 200ms;
            border: 2px solid;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            background: transparent;
        }

        .cyber-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            border-color: #00ff41;
            color: #00ff41;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #00ff41;
            color: black;
        }

        .btn-danger {
            border-color: #ff003c;
            color: #ff003c;
        }

        .btn-danger:hover:not(:disabled) {
            background-color: #ff003c;
            color: black;
        }

        .btn-secondary {
            border-color: #4b5563;
            color: #6b7280;
            font-size: 0.875rem;
            padding: 0.25rem 0.5rem;
        }

        .btn-secondary:hover:not(:disabled) {
            border-color: #9ca3af;
            color: #9ca3af;
        }

        /* Scrollbar hiding */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Icon Background for Card Back */
        .bg-icon {
            background-color: #000;
            background-image: url('./icon.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 3D CardFlip */
        .perspective-1000 {
            perspective: 1000px;
        }

        .transform-style-3d {
            transform-style: preserve-3d;
        }

        .backface-hidden {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .rotate-y-180 {
            transform: rotateY(180deg);
        }

        /* Elimination Screen */
        #elimination-screen {
            background: rgba(20, 0, 0, 0.9);
            border: 4px solid #ff003c;
            box-shadow: inset 0 0 50px #ff003c;
        }

        .glitch-text {
            position: relative;
            animation: glitch 1s linear infinite;
        }

        @keyframes glitch {

            2%,
            64% {
                transform: translate(2px, 0) skew(0deg);
            }

            4%,
            60% {
                transform: translate(-2px, 0) skew(0deg);
            }

            62% {
                transform: translate(0, 0) skew(5deg);
            }
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-repeat: no-repeat;
            background-size: cover;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>


<body class="h-screen w-screen crt flex flex-col items-center justify-center">
    <div class="scanline"></div>

    <!-- VIEW: LOADING -->
    <button id="btn-audio-toggle"
        class="absolute top-4 right-4 z-50 text-[#00ff41] border border-[#00ff41] px-2 py-1 text-xs opacity-50 hover:opacity-100">AUDIO:
        ON</button>
    <div id="view-loading" class="text-[#00ff41] animate-pulse text-xl">ESTABLISHING UPLINK...</div>

    <!-- VIEW: MENU -->
    <div id="view-menu" class="hidden flex-col items-center w-full max-w-md p-6 relative z-20">
        <div class="text-5xl md:text-6xl mb-2 font-bold neon-text tracking-tighter mt-8">MAFIA</div>
        <div class="text-sm mb-8 tracking-widest opacity-70">SECURE TERMINAL ACCESS</div>

        <div class="w-full space-y-6">
            <div class="space-y-2">
                <label class="text-xs uppercase tracking-widest opacity-60 block text-center">Identity</label>
                <input id="input-name" class="cyber-input" placeholder="ENTER ALIAS" maxlength="12">
            </div>

            <div class="grid grid-cols-1 gap-4">
                <button id="btn-create" class="cyber-btn btn-primary"><span class="relative z-10">Initialize
                        Host</span></button>

                <div class="relative border border-[#00ff41] p-4">
                    <label
                        class="absolute -top-3 left-1/2 transform -translate-x-1/2 bg-black px-2 text-xs text-[#00ff41]">MANUAL
                        OVERRIDE</label>
                    <div class="flex gap-2">
                        <input id="input-room-code"
                            class="w-2/3 bg-black border border-[#00ff41] p-2 text-center text-xl text-white uppercase outline-none"
                            placeholder="CODE" maxlength="4">
                        <button id="btn-join"
                            class="w-1/3 bg-[#00ff41] text-black font-bold hover:bg-white transition-colors">JOIN</button>
                    </div>
                </div>
            </div>

            <!-- Nearby Rooms -->
            <div class="mt-8 border-t border-[#00ff41]/30 pt-4 w-full">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-xs tracking-widest opacity-70">DETECTED SIGNALS (OPEN GAMES)</span>
                    <span id="nearby-count" class="text-xs animate-pulse text-[#00ff41]">0 FOUND</span>
                </div>
                <div id="nearby-list" class="space-y-2 max-h-48 overflow-y-auto no-scrollbar">
                    <!-- Dynamic Content -->
                </div>
            </div>

            <div id="menu-error"
                class="hidden text-[#ff003c] text-center border border-[#ff003c] p-2 animate-pulse font-bold bg-[#ff003c]/10">
            </div>
        </div>
    </div>

    <!-- VIEW: LOBBY -->
    <div id="view-lobby" class="hidden flex-col h-full w-full p-4 max-w-md mx-auto relative z-20">
        <div class="flex justify-between items-center border-b border-[#00ff41] pb-4 mb-4">
            <div>
                <div class="text-xs opacity-50">SESSION ID</div>
                <div id="lobby-code" class="text-4xl font-bold tracking-widest">----</div>
            </div>
            <button id="btn-leave" class="cyber-btn btn-secondary !w-auto">ABORT</button>
        </div>

        <div class="flex-1 overflow-y-auto mb-4">
            <div id="lobby-count-label" class="text-xs opacity-50 mb-2">CONNECTED AGENTS (0)</div>
            <div id="player-list" class="space-y-2">
                <!-- Dynamic Content -->
            </div>
        </div>

        <!-- Host Controls -->
        <div id="host-controls" class="hidden space-y-4 bg-[#001100] p-4 border border-[#00ff41]">
            <div>
                <label class="flex justify-between mb-2">
                    <span>MAFIA COUNT</span>
                    <span id="mafia-count-display" class="font-bold text-xl">1</span>
                </label>
                <input id="range-mafia" type="range" min="1" max="1" value="1"
                    class="w-full accent-[#00ff41] h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <div id="rec-mafia" class="text-xs text-right mt-1 opacity-50">RECOMMENDED: 1</div>
            </div>

            <!-- Timer Settings -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs uppercase mb-1">Discuss (s)</label>
                    <input id="input-time-discuss" type="number" value="120" min="10" max="600"
                        class="w-full bg-black border border-[#00ff41] p-2 text-center text-white outline-none">
                </div>
                <div>
                    <label class="block text-xs uppercase mb-1">Vote (s)</label>
                    <input id="input-time-vote" type="number" value="60" min="10" max="300"
                        class="w-full bg-black border border-[#00ff41] p-2 text-center text-white outline-none">
                </div>
            </div>

            <button id="btn-start" class="cyber-btn btn-primary" disabled>WAITING FOR AGENTS...</button>
        </div>

        <div id="waiting-msg" class="hidden text-center animate-pulse p-4 border border-[#00ff41]/50 bg-[#00ff41]/5">
            AWAITING HOST COMMAND...
        </div>
        <div id="lobby-error" class="mt-2 text-[#ff003c] text-center text-xs"></div>
    </div>

    <!-- VIEW: GAME -->
    <div id="view-game"
        class="hidden flex-col h-full w-full p-6 max-w-md mx-auto items-center relative z-20 overflow-y-auto no-scrollbar">

        <button id="btn-game-exit"
            class="absolute top-2 left-2 text-[0.6rem] border border-[#00ff41] text-[#00ff41] px-2 py-1 opacity-50 hover:opacity-100 bg-black z-50">LEAVE</button>

        <!-- Header: Timer & Phase -->
        <div class="w-full flex justify-between items-end border-b border-[#00ff41] pb-2 mb-4">
            <div>
                <div class="text-xs opacity-50">PHASE</div>
                <div id="game-phase" class="text-xl font-bold text-[#00ff41]">LOADING</div>
            </div>
            <div class="text-right">
                <div class="text-xs opacity-50">TIMER</div>
                <div id="game-timer" class="text-2xl font-bold font-mono text-[#ff003c]">00:00</div>
            </div>
        </div>

        <!-- Mafia Task (Hidden in DOM, moved to Card) -->
        <div id="mafia-task-container" class="hidden"></div>

        <!-- Role Card (Full Size / Emphasis) -->
        <div id="role-card"
            class="w-full max-w-xs mb-6 mx-auto flex-1 min-h-[400px] perspective-1000 cursor-pointer group select-none">
            <div id="card-inner" class="relative w-full h-full transform-style-3d transition-transform duration-700">

                <!-- Front (Revealed Content) - Actually Back in 3D terms until flipped -->
                <div
                    class="absolute w-full h-full backface-hidden rotate-y-180 border-2 border-[#00ff41] bg-black flex flex-col items-center justify-center p-4 text-center">
                    <div id="role-title" class="text-4xl md:text-6xl font-black tracking-tighter mb-4">ROLE</div>
                    <div id="role-desc" class="text-sm"></div>
                </div>

                <!-- Back (Hidden/Cover) - Front in 3D terms -->
                <div
                    class="absolute w-full h-full backface-hidden border-2 border-[#00ff41] bg-icon flex flex-col items-center justify-center">
                    <!-- Icon is background, text overlaid if needed, or removed for cleaner look -->
                    <!-- <div class="text-8xl font-black text-[#00ff41] opacity-20">M</div> -->
                    <!-- <div class="text-xs tracking-[0.5em] mt-4 text-[#00ff41]">CONFIDENTIAL</div> -->
                </div>

            </div>
        </div>
        <!-- Voting Section -->
        <div id="voting-section" class="w-full flex-1 mb-4">
            <div class="text-center text-xs opacity-50 mb-2 tracking-widest">NO SIGNAL...</div>
        </div>

        <!-- REMOVED Global Confirm Button in favor of Among Us style inline buttons -->

        <!-- Game Over Screen (Overlay) -->
        <div id="game-over-screen"
            class="hidden absolute inset-0 bg-black z-50 flex flex-col items-center justify-center p-8 text-center">
            <div id="winner-title" class="text-4xl md:text-6xl font-black neon-text mb-4">VICTORY</div>
            <div id="winner-desc" class="text-xl mb-8">THE CITY SLEEPS</div>
            <button id="btn-return-lobby" class="cyber-btn btn-primary">RETURN TO LOBBY</button>
        </div>

        <!-- Elimination Screen (Overlay) -->
        <div id="elimination-screen"
            class="hidden absolute inset-0 z-[60] flex flex-col items-center justify-center p-4 text-center pointer-events-none">

            <div id="elim-content" class="flex flex-col items-center transition-opacity duration-300">
                <div class="text-[#ff003c] text-3xl md:text-4xl font-black tracking-widest mb-2 glitch-text">TERMINATED
                </div>
                <div id="eliminated-player-name"
                    class="text-white text-3xl md:text-6xl font-bold mb-8 uppercase drop-shadow-[0_0_10px_rgba(255,0,0,0.8)]">
                    PLAYER
                </div>

                <!-- Victim Card -->
                <div id="victim-card"
                    class="w-48 h-64 border-2 border-[#ff003c] bg-black flex flex-col items-center justify-center relative shadow-[0_0_30px_#ff003c] mb-8">
                    <div id="victim-role" class="text-3xl md:text-4xl font-bold text-[#ff003c]">MAFIA</div>
                </div>
            </div>

            <div class="w-full h-1 bg-[#ff003c] animate-pulse absolute bottom-10"></div>
        </div>

        <button id="btn-game-terminate"
            class="hidden absolute top-0 right-0 -mt-8 text-[0.6rem] border border-[#ff003c] text-[#ff003c] px-2 py-1 opacity-50 hover:opacity-100">ABORT</button>

        <!-- PWA Install Prompt -->
        <div id="pwa-install-prompt"
            class="hidden fixed bottom-0 left-0 right-0 bg-black border-t border-[#00ff41] p-4 z-50 flex justify-between items-center shadow-[0_0_20px_rgba(0,255,65,0.3)]">
            <div>
                <div class="text-[#00ff41] font-bold text-lg leading-none">INSTALL PROTOCOL</div>
                <div class="text-xs text-[#00ff41] opacity-70">Add to home screen for better performance</div>
            </div>
            <div class="flex gap-2">
                <button id="btn-pwa-dismiss"
                    class="px-3 py-1 border border-[#00ff41] text-[#00ff41] text-sm hover:bg-[#00ff41]/20">LATER</button>
                <button id="btn-pwa-install"
                    class="px-3 py-1 bg-[#00ff41] text-black font-bold text-sm hover:bg-[#00ff41]/80">INSTALL</button>
            </div>
        </div>
    </div>

    <script>
        // --- PWA Logic ---
        if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.protocol === 'http:')) {
            navigator.serviceWorker.register('./service-worker.js')
                .then(() => console.log('Service Worker Registered'))
                .catch((err) => console.log('SW Failed:', err));
        }

        let deferredPrompt;
        const installPromptEl = document.getElementById('pwa-install-prompt');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installPromptEl.classList.remove('hidden');
        });

        document.getElementById('btn-pwa-install').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    deferredPrompt = null;
                }
                installPromptEl.classList.add('hidden');
            }
        });

        document.getElementById('btn-pwa-dismiss').addEventListener('click', () => {
            installPromptEl.classList.add('hidden');
        });

        // --- Globals ---
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBORyn9Hl_6HS2HZwtg1UoK6ooQCj5HbaU",
            authDomain: "mafia-game-7db3c.firebaseapp.com",
            projectId: "mafia-game-7db3c",
            storageBucket: "mafia-game-7db3c.firebasestorage.app",
            messagingSenderId: "354714689130",
            appId: "1:354714689130:web:5907e78f3828ce44ef3413",
            measurementId: "G-MQ6L411MYN"
        };
        // const firebaseConfig = JSON.parse(__firebase_config);
        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';

        let currentUser = null;
        let currentRoomCode = '';
        let roomData = null;
        let unsubscribeRoom = null;
        let unsubscribeNearby = null;
        let isCardRevealed = false;
        let gameInterval = null;
        let timerUiInterval = null;
        let myPublicIp = null;
        let selectedTarget = null;

        const PHASES = {
            DISCUSSION: 'DISCUSSION',
            VOTING: 'VOTING',
            PLEA: 'PLEA',
            REVOTE: 'REVOTE',
            RESULT: 'RESULT',
            GAME_OVER: 'GAME_OVER'
        };

        const MAFIA_TASKS = [
            "Touch your hair 3 times", "Touch [TARGET]'s shoulder", "Cough loudly once",
            "Rub your nose twice", "Stretch your arms up", "Yawn audibly",
            "Tap the table 5 times", "Cross your legs instantly", "Mention the word 'Pizza'",
            "Compliment [TARGET]", "Scratch your ear", "Blink rapidly for 3 seconds",
            "Nod aggressively at [TARGET]", "Stand up and sit down", "Check your phone visibly",
            "Ask 'What time is it?'", "Hum a tune", "Adjust your shirt collar",
            "Laugh at something [TARGET] says", "Say 'I suspect myself'"
        ];

        // --- Sound Manager ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
                this.osc = null; // Ambience oscillator
            }

            toggle() {
                this.enabled = !this.enabled;
                if (!this.enabled) this.stopAmbience();
                else this.playAmbience();
                return this.enabled;
            }

            playTone(freq, type, duration, vol = 0.1) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playClick() { this.playTone(800, 'square', 0.1, 0.05); }
            playHover() { this.playTone(200, 'sine', 0.05, 0.02); }
            playAlert() { this.playTone(400, 'sawtooth', 0.3, 0.1); }
            playWin() {
                [0, 200, 400].forEach(delay =>
                    setTimeout(() => this.playTone(600 + delay, 'square', 0.2, 0.1), delay)
                );
            }

            playAmbience() {
                if (!this.enabled || this.osc) return;
                this.osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                this.osc.type = 'sine';
                this.osc.frequency.setValueAtTime(50, this.ctx.currentTime); // Low Drone
                gain.gain.setValueAtTime(0.02, this.ctx.currentTime);
                this.osc.connect(gain);
                gain.connect(this.ctx.destination);
                this.osc.start();
            }

            stopAmbience() {
                if (this.osc) {
                    this.osc.stop();
                    this.osc = null;
                }
            }

            playHeartbeat() {
                if (!this.enabled) return;
                const now = this.ctx.currentTime;

                // Beat 1
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.frequency.setValueAtTime(60, now);
                osc1.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gain1.gain.setValueAtTime(0.5, now);
                gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc1.connect(gain1);
                gain1.connect(this.ctx.destination);
                osc1.start(now);
                osc1.stop(now + 0.1);

                // Beat 2 (slightly softer, delayed)
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.frequency.setValueAtTime(60, now + 0.2);
                osc2.frequency.exponentialRampToValueAtTime(40, now + 0.3);
                gain2.gain.setValueAtTime(0.3, now + 0.2);
                gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc2.connect(gain2);
                gain2.connect(this.ctx.destination);
                osc2.start(now + 0.2);
                osc2.stop(now + 0.3);
            }

            playFlatline() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth'; // Harsh sound
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 2); // Pitch drop
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 3);
            }

        }

        const sound = new SoundManager();

        // --- DOM Elements ---
        const views = {
            loading: document.getElementById('view-loading'),
            menu: document.getElementById('view-menu'),
            lobby: document.getElementById('view-lobby'),
            game: document.getElementById('view-game')
        };
        const inputName = document.getElementById('input-name');
        const inputRoomCode = document.getElementById('input-room-code');
        const errorDisplays = {
            menu: document.getElementById('menu-error'),
            lobby: document.getElementById('lobby-error')
        };
        // btnConfirmVote removed
        const btnAudio = document.getElementById('btn-audio-toggle');

        btnAudio.addEventListener('click', () => {
            const on = sound.toggle();
            btnAudio.textContent = `AUDIO: ${on ? 'ON' : 'OFF'}`;
            btnAudio.style.opacity = on ? '1' : '0.5';
        });

        // Add Hover sounds globally
        document.addEventListener('mouseover', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.classList.contains('group')) sound.playHover();
        });
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') sound.playClick();
        });

        // --- Initialization ---
        async function getPublicIP() {
            try {
                const res = await fetch('https://api.ipify.org?format=json');
                const data = await res.json();
                return data.ip;
            } catch (e) {
                console.error("IP Fetch Failed", e);
                return 'unknown';
            }
        }

        async function init() {
            // Restore local data
            const savedName = localStorage.getItem('mafia_name');
            if (savedName) inputName.value = savedName;

            const savedCode = localStorage.getItem('mafia_room');
            if (savedCode) currentRoomCode = savedCode;

            // Auth
            auth.onAuthStateChanged((user) => {
                currentUser = user;
                if (user) {
                    if (currentRoomCode) {
                        subscribeToRoom(currentRoomCode);
                    } else {
                        switchView('menu');
                        getPublicIP().then(ip => {
                            myPublicIp = ip;
                            console.log("My IP:", myPublicIp);
                            subscribeToNearby();
                        });
                    }
                } else {
                    signIn();
                }
            });
        }

        async function signIn() {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await auth.signInWithCustomToken(__initial_auth_token);
            } else {
                await auth.signInAnonymously();

                // Init Ambience on user interaction if needed (browser policy)
                if (sound.ctx.state === 'suspended') sound.ctx.resume();
                sound.playAmbience();
            }
        }

        // --- View Management ---
        function switchView(viewName) {
            Object.values(views).forEach(el => el.classList.add('hidden'));
            views[viewName].classList.remove('hidden');

            // Flex handling because hidden uses display:none
            if (viewName === 'menu' || viewName === 'lobby' || viewName === 'game') {
                views[viewName].classList.add('flex');
            }
        }

        function showError(msg, context = 'menu') {
            const el = errorDisplays[context];
            if (el) {
                el.textContent = msg;
                el.classList.remove('hidden');
                setTimeout(() => {
                    el.classList.add('hidden');
                    el.textContent = '';
                }, 3000);
            }
        }

        // --- Logic: Menu ---
        inputName.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
            localStorage.setItem('mafia_name', e.target.value);
        });

        inputRoomCode.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
        });

        document.getElementById('btn-create').addEventListener('click', async () => {
            const name = inputName.value.trim();
            if (!name) return showError("IDENTIFY YOURSELF FIRST");

            const code = Math.random().toString(36).substring(2, 6).toUpperCase();
            const newRoom = {
                hostId: currentUser.uid,
                hostName: name,
                status: 'lobby',
                mafiaCount: 1,
                publicIp: myPublicIp,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                players: [{ uid: currentUser.uid, name: name, role: null }]
            };

            try {
                await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(code).set(newRoom);
                currentRoomCode = code;
                subscribeToRoom(code);
            } catch (err) {
                showError("CREATION FAILED");
            }
        });

        document.getElementById('btn-join').addEventListener('click', () => {
            const code = inputRoomCode.value.trim().toUpperCase();
            joinGame(code);
        });

        async function joinGame(code) {
            const name = inputName.value.trim();
            if (!name) return showError("IDENTIFY YOURSELF FIRST");
            if (code.length !== 4) return showError("INVALID ACCESS CODE");

            const roomRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(code);

            try {
                await db.runTransaction(async (transaction) => {
                    const doc = await transaction.get(roomRef);
                    if (!doc.exists) throw "Room not found";
                    const data = doc.data();
                    if (data.status !== 'lobby') throw "Game in progress";

                    const existingPlayer = data.players.find(p => p.uid === currentUser.uid);
                    if (!existingPlayer) {
                        const newPlayers = [...data.players, { uid: currentUser.uid, name: name, role: null }];
                        transaction.update(roomRef, { players: newPlayers });
                    }
                });
                currentRoomCode = code;
                subscribeToRoom(code);
            } catch (e) {
                showError(typeof e === 'string' ? e : "Connection Failed");
            }
        }

        function subscribeToNearby() {
            if (unsubscribeNearby) unsubscribeNearby();
            const roomsRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms');

            unsubscribeNearby = roomsRef.onSnapshot((snapshot) => {
                const listEl = document.getElementById('nearby-list');
                const countEl = document.getElementById('nearby-count');
                listEl.innerHTML = '';

                let count = 0;
                snapshot.forEach(doc => {
                    const d = doc.data();
                    // Filter by Wifi only if IP is known
                    if (d.status === 'lobby' && (d.publicIp === myPublicIp || !d.publicIp || d.publicIp === 'unknown')) {
                        count++;
                        const item = document.createElement('div');
                        item.className = "w-full flex items-center justify-between p-3 border border-[#00ff41]/40 hover:bg-[#00ff41]/10 hover:border-[#00ff41] transition-all cursor-pointer group";
                        item.innerHTML = `
                            <div>
                                <div class="text-lg font-bold group-hover:neon-text">${d.hostName}'S LOBBY</div>
                                <div class="text-xs opacity-50">ID: ${doc.id}</div> 
                            </div>
                            <div class="text-right">
                                <div class="text-xl">${d.players.length} <span class="text-xs opacity-50">AGENTS</span></div>
                            </div>
                        `;
                        item.onclick = () => joinGame(doc.id);
                        listEl.appendChild(item);
                    }
                });

                if (count === 0) {
                    listEl.innerHTML = `<div class="text-center py-4 opacity-30 italic text-sm border border-[#00ff41]/20">NO ACTIVE SIGNALS</div>`;
                }
                countEl.textContent = `${count} FOUND`;
            });
        }

        // --- Logic: Room (Lobby & Game) ---
        function subscribeToRoom(code) {
            if (unsubscribeRoom) unsubscribeRoom();

            const roomRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(code);

            unsubscribeRoom = roomRef.onSnapshot((doc) => {
                if (!doc.exists) {
                    handleRoomExit("SIGNAL LOST: ROOM CLOSED");
                    return;
                }

                roomData = doc.data();

                if (roomData.status === 'closed') {
                    handleRoomExit("HOST TERMINATED CONNECTION");
                    return;
                }

                localStorage.setItem('mafia_room', code);

                if (roomData.status === 'lobby') {
                    isCardRevealed = false; // Reset for new game
                    hasGameStartedEffectsRun = false; // Reset effects flag
                    renderLobby();
                    switchView('lobby');
                } else if (roomData.status === 'playing') {
                    renderGame();
                    switchView('game');
                }
            }, (err) => {
                console.error(err);
                // Don't auto-kick on network blip
            });
        }

        // --- Logic: Game Start Effects ---
        let hasGameStartedEffectsRun = false;
        let lastProcessedElimination = 0; // Timestamp of last shown death

        function runGameStartEffects() {
            if (hasGameStartedEffectsRun) return;
            hasGameStartedEffectsRun = true;

            // Heartbeat
            sound.playHeartbeat();
            const hbInterval = setInterval(() => sound.playHeartbeat(), 1000); // Repeat every second for intensity? Or just once? User said "intense sound like fast heartbeat". Let's loop it fast for 4s.

            // Actually, let's do a fast heartbeat for 4 seconds
            clearInterval(hbInterval); // clear the one definition above
            let beats = 0;
            const fastHb = setInterval(() => {
                sound.playHeartbeat();
                beats++;
                if (beats >= 8) clearInterval(fastHb); // 2 beats per sec for 4 secs
            }, 500);

            // Auto Reveal Card
            if (!isCardRevealed) {
                isCardRevealed = true;
                cardInner.classList.add('rotate-y-180');

                // Hide after 4 seconds
                setTimeout(() => {
                    isCardRevealed = false;
                    cardInner.classList.remove('rotate-y-180');
                    sound.playTone(200, 'sine', 0.5); // Closing sound
                }, 4000);
            }
        }

        async function handleRoomExit(msg) {
            sound.stopAmbience();
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }

            // If I am host, close the room
            if (roomData && roomData.hostId === currentUser.uid && roomData.status !== 'closed') {
                await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(currentRoomCode).update({
                    status: 'closed'
                });
            }

            if (timerUiInterval) {
                clearInterval(timerUiInterval);
                timerUiInterval = null;
            }
            localStorage.removeItem('mafia_room');
            currentRoomCode = '';
            roomData = null;
            if (msg) showError(msg, 'menu');
            switchView('menu');
            sound.playAmbience(); // Restart menu ambience if desired
            subscribeToNearby();
        }

        document.getElementById('btn-leave').addEventListener('click', () => handleRoomExit());
        document.getElementById('btn-game-exit').addEventListener('click', () => handleRoomExit());

        // --- Logic: Lobby Rendering ---
        const rangeMafia = document.getElementById('range-mafia');
        const btnStart = document.getElementById('btn-start');

        rangeMafia.addEventListener('input', (e) => {
            document.getElementById('mafia-count-display').textContent = e.target.value;
        });

        btnStart.addEventListener('click', async () => {
            if (!roomData) return;
            const players = [...roomData.players];
            const mCount = parseInt(rangeMafia.value);
            const discussTime = parseInt(document.getElementById('input-time-discuss').value) || 120;
            const voteTime = parseInt(document.getElementById('input-time-vote').value) || 60;

            const newPlayers = players.map(p => ({ ...p, role: 'CIVILIAN', status: 'ALIVE', votes: 0 }));
            let assigned = 0;
            while (assigned < mCount) {
                const idx = Math.floor(Math.random() * players.length);
                if (newPlayers[idx].role !== 'MAFIA') {
                    newPlayers[idx].role = 'MAFIA';
                    assigned++;
                }
            }

            let task = MAFIA_TASKS[Math.floor(Math.random() * MAFIA_TASKS.length)];

            // Inject Random Target Name
            if (task.includes('[TARGET]')) {
                const potentialTargets = newPlayers.filter(p => p.role !== 'MAFIA');
                const target = potentialTargets.length > 0
                    ? potentialTargets[Math.floor(Math.random() * potentialTargets.length)].name
                    : "ANYONE";
                task = task.replace('[TARGET]', target);
            }

            await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(currentRoomCode).set({
                status: 'playing',
                players: newPlayers,
                mafiaCount: mCount,
                round: 1,
                phase: PHASES.DISCUSSION,
                phaseEndTime: Date.now() + (discussTime * 1000),
                discussionTime: discussTime,
                votingTime: voteTime,
                mafiaTask: task,
                tiedPlayers: [],
                hostId: currentUser.uid,
                hostName: roomData.hostName,
                createdAt: roomData.createdAt
            }, { merge: true }); // Use set with merge to be robust
        });

        function renderLobby() {
            document.getElementById('lobby-code').textContent = currentRoomCode;
            document.getElementById('lobby-count-label').textContent = `CONNECTED AGENTS (${roomData.players.length})`;

            const list = document.getElementById('player-list');
            list.innerHTML = '';

            roomData.players.forEach(p => {
                const row = document.createElement('div');
                row.className = "flex items-center gap-2 p-2 border border-[#00ff41]/30 bg-black/50";
                const isHost = p.uid === roomData.hostId;
                row.innerHTML = `
                    <div class="w-2 h-2 ${isHost ? 'bg-yellow-400' : 'bg-[#00ff41]'}"></div>
                    <span class="${p.uid === currentUser.uid ? 'font-bold text-white' : ''}">${p.name} ${p.uid === currentUser.uid ? '(YOU)' : ''}</span>
                    ${isHost ? '<span class="ml-auto text-xs bg-yellow-400 text-black px-1 font-bold">HOST</span>' : ''}
                `;
                list.appendChild(row);
            });

            const isMyHost = roomData.hostId === currentUser.uid;
            const hostControls = document.getElementById('host-controls');
            const waitingMsg = document.getElementById('waiting-msg');

            if (isMyHost) {
                hostControls.classList.remove('hidden');
                waitingMsg.classList.add('hidden');

                const maxMafia = Math.max(1, Math.floor((roomData.players.length - 1) / 2));
                rangeMafia.max = maxMafia;

                // Recalculate range validation
                if (parseInt(rangeMafia.value) > maxMafia) rangeMafia.value = maxMafia;
                document.getElementById('mafia-count-display').textContent = rangeMafia.value;
                document.getElementById('rec-mafia').textContent = `RECOMMENDED: ${Math.floor(roomData.players.length / 3) || 1}`;

                if (roomData.players.length < 3) {
                    btnStart.textContent = "WAITING FOR AGENTS (3+)...";
                    btnStart.disabled = true;
                } else {
                    btnStart.textContent = "INITIATE PROTOCOL";
                    btnStart.disabled = false;
                }
            } else {
                hostControls.classList.add('hidden');
                waitingMsg.classList.remove('hidden');
            }
        }

        // --- Logic: Game Rendering ---
        const cardInner = document.getElementById('card-inner');
        const roleCard = document.getElementById('role-card');
        const btnTerminate = document.getElementById('btn-game-terminate');

        roleCard.addEventListener('click', () => {
            isCardRevealed = !isCardRevealed;
            if (isCardRevealed) {
                sound.playTone(300, 'triangle', 0.5); // Card Flip Sound
                cardInner.classList.add('rotate-y-180');
            } else {
                cardInner.classList.remove('rotate-y-180');
            }
            // slight delay to update text to avoid cheating by DOM inspection before anim? 
            // Actually DOM is updated always, CSS hides backface.
            setTimeout(updateCardVisuals, 300); // Wait for half spin
        });

        btnTerminate.addEventListener('click', async () => {
            await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(currentRoomCode).update({
                status: 'lobby',
                players: roomData.players.map(p => ({ ...p, role: null }))
            });
        });

        function updateCardVisuals() {
            const myPlayer = roomData.players.find(p => p.uid === currentUser.uid);
            const isMafia = myPlayer?.role === 'MAFIA';

            const title = document.getElementById('role-title');
            const desc = document.getElementById('role-desc');
            const frontFace = cardInner.querySelector('.rotate-y-180'); // The content face

            if (isMafia) {
                title.textContent = "MAFIA";
                title.className = "text-6xl font-black mafia-text tracking-tighter mb-4";

                // Red Border on Reveal Face
                frontFace.classList.remove('border-[#00ff41]');
                frontFace.classList.add('border-[#ff003c]');

                const task = roomData.mafiaTask || 'NONE';
                desc.innerHTML = `
                    <div class="mb-4">ELIMINATE THE CIVILIANS.</div>
                    <div class="border border-[#ff003c] bg-[#ff003c]/20 p-2 text-sm font-bold text-white shadow-md">
                        SECRET ORDER:<br/>
                        ${task}
                    </div>
                `;
                desc.className = "text-[#ff003c] text-sm px-4 w-full";
            } else {
                title.textContent = "CIVILIAN";
                title.className = "text-5xl font-black civilian-text tracking-tighter mb-4";

                // Green Border on Reveal Face
                frontFace.classList.remove('border-[#ff003c]');
                frontFace.classList.add('border-[#00ff41]');

                desc.innerHTML = "IDENTIFY THE TRAITOR.<br/>SURVIVE.";
                desc.className = "text-[#00ff41] text-sm px-4";
            }
        }

        function renderGame() {
            if (!roomData) return;

            // Host Looping Logic
            const isMyHost = roomData.hostId === currentUser.uid;
            if (isMyHost && !gameInterval) {
                startGameLoop();
            } else if (!isMyHost && gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }

            // Trigger Start Effects if just started (Discussion phase, round 1 roughly, or just check local flag)
            // We use a local flag `hasGameStartedEffectsRun` reset on lobby.
            if (!hasGameStartedEffectsRun) {
                runGameStartEffects();
            }

            // Check for Elimination Event
            if (roomData.eliminationEvent && roomData.eliminationEvent.timestamp > lastProcessedElimination) {
                const event = roomData.eliminationEvent;
                // Only show if recent (within 10s) to avoid showing on late join
                if (Date.now() - event.timestamp < 10000) {
                    showEliminationAnimation(event.victim, event.role || 'UNKNOWN');
                }
                lastProcessedElimination = event.timestamp;
            }

            // Update Header
            // Update Header via Interval for smoothness
            if (!timerUiInterval) {
                timerUiInterval = setInterval(updateTimerDisplay, 500);
            }
            updateTimerDisplay(); // Immediate update

            // Mafia Task (Visibility)
            // Note: Task is now displayed inside the card.
            const myPlayer = roomData.players.find(p => p.uid === currentUser.uid);
            const isMafia = myPlayer?.role === 'MAFIA';

            // Game Over Check
            if (roomData.phase === PHASES.GAME_OVER) {
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('winner-desc').textContent = roomData.winner === 'MAFIA'
                    ? "THE MAFIA HAS TAKEN CONTROL"
                    : "THE CITY IS SAFE... FOR NOW";
                return; // Stop rendering other game elements
            } else {
                document.getElementById('game-over-screen').classList.add('hidden');
            }

            // Voting / Status Section
            const votingSection = document.getElementById('voting-section');
            votingSection.innerHTML = '';

            if (roomData.phase === PHASES.DISCUSSION) {
                votingSection.innerHTML = `<div class="text-center opacity-50 mt-8">DISCUSS SUSPICIOUS BEHAVIOR...</div>`;
            } else if (roomData.phase === PHASES.VOTING || roomData.phase === PHASES.REVOTE) {
                // Render Voting List
                const title = document.createElement('div');
                title.className = "text-center text-[#ff003c] font-bold mb-4 animate-pulse";
                title.textContent = roomData.phase === PHASES.REVOTE ? "TIE! REVOTE REQUIRED" : "CAST YOUR VOTE";
                votingSection.appendChild(title);

                const validTargets = roomData.phase === PHASES.REVOTE
                    ? roomData.players.filter(p => roomData.tiedPlayers.includes(p.uid))
                    : roomData.players.filter(p => p.status === 'ALIVE');

                // Check if I already voted
                const myVote = (roomData.votes || []).find(v => v.voter === currentUser.uid);

                if (myVote) {
                    votingSection.innerHTML += `<div class="text-center text-[#ff003c] p-4 border border-[#ff003c]">VOTE LOCKED: ${myVote.target === currentUser.uid ? 'SELF' : roomData.players.find(p => p.uid === myVote.target)?.name || 'UNKNOWN'}</div>`;
                } else {
                    validTargets.forEach(p => {
                        const isSelected = selectedTarget === p.uid;
                        const btn = document.createElement('div');

                        // New Inline Voting UI
                        if (isSelected && myPlayer.status === 'ALIVE') {
                            btn.className = "w-full p-2 border border-[#00ff41] bg-[#00ff41]/10 mb-2 flex items-center justify-between transition-all duration-300";
                            btn.innerHTML = `
                                <span class="text-lg font-bold ml-2">${p.name}</span>
                                <div class="flex gap-2">
                                     <button id="btn-cancel-${p.uid}" class="bg-gray-800 text-white p-2 text-xs border border-gray-600 hover:bg-gray-700">CANCEL</button>
                                     <button id="btn-confirm-${p.uid}" class="bg-[#ff003c] text-white p-2 font-bold text-xs border border-[#ff003c] hover:bg-black hover:text-[#ff003c] animate-pulse">CONFIRM</button>
                                </div>
                            `;
                            setTimeout(() => {
                                document.getElementById(`btn-cancel-${p.uid}`).onclick = (e) => { e.stopPropagation(); selectedTarget = null; sound.playClick(); renderGame(); };
                                document.getElementById(`btn-confirm-${p.uid}`).onclick = (e) => { e.stopPropagation(); castVote(p.uid); sound.playAlert(); };
                            }, 0);
                        } else {
                            btn.className = `w-full p-3 border mb-2 transition-colors flex justify-between items-center cursor-pointer ${myPlayer.status !== 'ALIVE' ? 'opacity-50 border-gray-600' : 'border-[#00ff41] hover:bg-[#00ff41] hover:text-black'}`;
                            btn.innerHTML = `<span>${p.name}</span> <span class="text-xs opacity-50">VOTE</span>`;
                            if (myPlayer.status === 'ALIVE') {
                                btn.onclick = () => {
                                    selectedTarget = p.uid;
                                    sound.playClick();
                                    renderGame();
                                };
                            }
                        }
                        votingSection.appendChild(btn);
                    });
                }
            } else if (roomData.phase === PHASES.PLEA) {
                votingSection.innerHTML = `<div class="text-center text-xl text-[#00ff41] mt-8 p-4 border border-[#00ff41]">
                    <div class="mb-2">DEFENSE PHASE</div>
                    <div class="text-sm opacity-70">ACCUSED ARE PLEADING INNOCENCE</div>
                 </div>`;
            }

            // Card Update
            updateCardVisuals();

            if (isMyHost) {
                btnTerminate.classList.remove('hidden');
            } else {
                btnTerminate.classList.add('hidden');
            }
        }

        function updateTimerDisplay() {
            if (!roomData) return;
            const timeLeft = Math.max(0, Math.ceil((roomData.phaseEndTime - Date.now()) / 1000));
            const mins = Math.floor(timeLeft / 60).toString().padStart(2, '0');
            const secs = (timeLeft % 60).toString().padStart(2, '0');

            const timerEl = document.getElementById('game-timer');
            if (timerEl) timerEl.textContent = `${mins}:${secs}`;

            const phaseEl = document.getElementById('game-phase');
            if (phaseEl) phaseEl.textContent = roomData.phase;
        }

        function showEliminationAnimation(name, role) {
            const el = document.getElementById('elimination-screen');
            const nameEl = document.getElementById('eliminated-player-name');
            const cardEl = document.getElementById('victim-card');
            const roleEl = document.getElementById('victim-role');
            const contentEl = document.getElementById('elim-content');

            nameEl.textContent = name;
            roleEl.textContent = role;
            roleEl.className = role === 'MAFIA' ? "text-3xl md:text-4xl font-black text-[#ff003c]" : "text-3xl md:text-4xl font-black text-[#00ff41]";
            cardEl.style.opacity = '1';
            contentEl.style.opacity = '1';

            el.classList.remove('hidden');
            sound.playFlatline();

            // Ripping / Shatter Effect after 1.5s
            setTimeout(() => {
                createShatterEffect(cardEl, role);
                cardEl.style.opacity = '0'; // Hide original

                sound.playTone(100, 'sawtooth', 0.2); // Crunch sound

                // Fade out text
                setTimeout(() => {
                    contentEl.style.opacity = '0';
                }, 1000);

            }, 2000);

            // Hide after 5 seconds
            setTimeout(() => {
                el.classList.add('hidden');
            }, 5000);
        }

        function createShatterEffect(element, role) {
            const rect = element.getBoundingClientRect();
            const particles = 40;
            const color = role === 'MAFIA' ? '#ff003c' : '#00ff41'; // Color base

            for (let i = 0; i < particles; i++) {
                const part = document.createElement('div');
                part.classList.add('particle');

                // Random Size
                const size = Math.random() * 20 + 5;
                part.style.width = `${size}px`;
                part.style.height = `${size}px`;
                part.style.backgroundColor = Math.random() > 0.5 ? 'black' : color;
                if (Math.random() > 0.8) part.style.border = `1px solid ${color}`;

                // Start Position (spread within card)
                const startX = rect.left + Math.random() * rect.width;
                const startY = rect.top + Math.random() * rect.height;
                part.style.left = `${startX}px`;
                part.style.top = `${startY}px`;

                document.body.appendChild(part);

                // Animation
                const destX = (Math.random() - 0.5) * 500;
                const destY = (Math.random() - 0.5) * 500;
                const rot = (Math.random() - 0.5) * 720;

                part.animate([
                    { transform: `translate(0,0) rotate(0deg)`, opacity: 1 },
                    { transform: `translate(${destX}px, ${destY}px) rotate(${rot}deg)`, opacity: 0 }
                ], {
                    duration: 1000 + Math.random() * 1000,
                    easing: 'cubic-bezier(0.25, 1, 0.5, 1)',
                    fill: 'forwards'
                }).onfinish = () => part.remove();
            }
        }

        async function castVote(targetUid) {
            // In a real app, use a subcollection for votes to prevent tampering.
            // For this single-doc structure: host counts votes, or we update an array.
            // Let's use a "votes" array in roomData: [{voter: uid, target: uid}]

            const myVote = (roomData.votes || []).find(v => v.voter === currentUser.uid);
            if (myVote) return showError("ALREADY VOTED");

            const newVotes = [...(roomData.votes || []), { voter: currentUser.uid, target: targetUid }];

            await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(currentRoomCode).update({
                votes: newVotes
            });
            selectedTarget = null; // Reset selection
        }

        function startGameLoop() {
            gameInterval = setInterval(async () => {
                if (!roomData || roomData.status !== 'playing' || roomData.hostId !== currentUser.uid) return;

                const now = Date.now();

                // Check if Everyone Voted (Early End)
                if (roomData.phase === PHASES.VOTING || roomData.phase === PHASES.REVOTE) {
                    const validVoters = roomData.players.filter(p => p.status === 'ALIVE').length;
                    const currentVotes = (roomData.votes || []).length;
                    if (currentVotes >= validVoters && validVoters > 0) {
                        await advancePhase();
                        return; // Skip time check
                    }
                }

                if (now >= roomData.phaseEndTime) {
                    await advancePhase();
                }
            }, 1000);
        }

        async function advancePhase() {
            const currentPhase = roomData.phase;
            let updates = {};

            if (currentPhase === PHASES.DISCUSSION) {
                // Discussion -> Voting
                updates = {
                    phase: PHASES.VOTING,
                    phaseEndTime: Date.now() + ((roomData.votingTime || 60) * 1000),
                    votes: [] // Reset votes
                };
            } else if (currentPhase === PHASES.VOTING || currentPhase === PHASES.REVOTE) {
                // Count Votes
                const votes = roomData.votes || [];
                const counts = {};
                votes.forEach(v => counts[v.target] = (counts[v.target] || 0) + 1);

                // Find max
                let maxVotes = 0;
                let candidates = [];
                Object.entries(counts).forEach(([uid, count]) => {
                    if (count > maxVotes) {
                        maxVotes = count;
                        candidates = [uid];
                    } else if (count === maxVotes) {
                        candidates.push(uid);
                    }
                });

                if (candidates.length === 0) {
                    // No votes? Back to discussion or next round? Let's just go next round.
                    updates = startNextRound();
                } else if (candidates.length > 1) {
                    // Tie
                    if (currentPhase === PHASES.REVOTE) {
                        // Tie after revote? No one eliminated.
                        updates = startNextRound();
                    } else {
                        // Go to Plea
                        updates = {
                            phase: PHASES.PLEA,
                            phaseEndTime: Date.now() + (candidates.length * 10 * 1000), // 10s per person
                            tiedPlayers: candidates,
                            votes: []
                        };
                    }
                } else {
                    // Elimination
                    const victimUid = candidates[0];
                    const players = [...roomData.players];
                    const pIdx = players.findIndex(p => p.uid === victimUid);
                    let eliminationEvent = null;

                    if (pIdx !== -1) {
                        players[pIdx].status = 'ELIMINATED';
                        players[pIdx].role = 'SPECTATOR'; // Reveal role? Or keep hidden?
                        eliminationEvent = {
                            victim: players[pIdx].name,
                            role: players[pIdx].role, // Added role
                            timestamp: Date.now()
                        };
                    }

                    // Check Win
                    const aliveMafia = players.filter(p => p.role === 'MAFIA' && p.status === 'ALIVE').length;
                    const aliveCiv = players.filter(p => p.role === 'CIVILIAN' && p.status === 'ALIVE').length;

                    if (aliveMafia === 0) {
                        sound.playWin(); // Victory music/sound
                        updates = { phase: PHASES.GAME_OVER, winner: 'CIVILIAN', players, eliminationEvent };
                    } else if (aliveCiv === 0) {
                        sound.playWin();
                        updates = { phase: PHASES.GAME_OVER, winner: 'MAFIA', players, eliminationEvent };
                    } else {
                        updates = { ...startNextRound(players), phase: PHASES.DISCUSSION, eliminationEvent }; // Logic reuse
                    }
                }
            } else if (currentPhase === PHASES.PLEA) {
                // Plea -> Revote
                updates = {
                    phase: PHASES.REVOTE,
                    phaseEndTime: Date.now() + (60 * 1000),
                    votes: []
                };
            }



            await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(currentRoomCode).update(updates);
        }

        function startNextRound(currentPlayers = null) {
            const task = MAFIA_TASKS[Math.floor(Math.random() * MAFIA_TASKS.length)];
            return {
                phase: PHASES.DISCUSSION,
                phaseEndTime: Date.now() + ((roomData.discussionTime || 120) * 1000),
                mafiaTask: task,
                votes: [],
                tiedPlayers: [],
                players: currentPlayers || roomData.players
            };
        }

        document.getElementById('btn-return-lobby').addEventListener('click', async () => {
            await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('mafia_rooms').doc(currentRoomCode).update({
                status: 'lobby',
                players: roomData.players.map(p => ({ ...p, role: null, status: 'ALIVE' }))
            });
        });

        // Start
        init();

    </script>
</body>

</html>
